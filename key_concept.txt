1- 对递归概念的理解：
1）递归，有着分而治之的思想，本质就是操作系统或者编译器生成系统栈，在某个执行过程中把子过程的相应环境信息压入栈中，当达到递归基的时候，开始弹出
栈，然后子过程再利用递归基返回的值进行相应的计算。
2）相应环境信息包括：子过程被调用的行号、子过程被调用前所生成的变量、指针等...
3）如何分析递归时间复杂度：
若递归时，每次划分有效子问题规模都相等，则可以用master公式来计算
// N是原问题的规模样本量，T是其当样本量=N时的时间复杂度，其中a是子过程宏观上发生的次数， b是子过程的样本量， O(N^d)是指最后两个子问题合并起来的时间复杂度
T(N) = aT(n/b) + O(N^d)
情况1：当以b为底,a为指数的log时, log(b,a) > d  时，则时间复杂度为O(N^log(b,a))
情况2：当以b为底,a为指数的log时, log(b,a) == d 时，则时间复杂度为O(N^d * logN)
情况3：当以b为底,a为指数的log时, log(b,a) < d  时，则时间复杂度为O(N^d)

//其他情况使用其他递归公式进行分析，大多数二分分治思想，都满足T(N) = aT(n/b) + O(N^d)



2- 快速排序：
1）经典2路排序的问题：与数据分布和数据特点有关，选取的key如果不够好，那么partition的过程就会发生问题规模极其不平衡的状态，
最坏情况下，在数据分布几乎有序情况下，每一次使用最后一个数，容易退变为O(N^2)级别的算法
2）引入3路随机化快排，可以解决任何数据分布的情况下，也能选出好的key，在数据分布几乎有序情况下，避免了每次都可以最坏情况的发生，最坏情况下的时间复杂度也可以达到O(N*logN)级别
思路：随机选取一个数，与待排序数组的最后一个数进行划分，注意more区域初始状态包含数组最后一个数，可以省一个变量
具体实现：
rand.Seed(int64(R-L+1) + time.Now().Unix())  //设置随机种子
randIndex := L + rand.Intn(R-L+1)  // 0~9都是随机选择的概率
3）代码简洁说明常数项系数比较低，归并排序的系数是比随机快排高的，因为merge的过程有多个for循环、生成临时数组、还有数组copy等操作



3- 堆：
1）堆，就是一棵完全二叉树，注意别与二叉平衡树混淆【满二叉树也是完全二叉树的一种】
2）大根堆，就是任意局部的子树的根节点的值都是最大值，小根堆与之相反
3）堆的具体实现使用数组实现
4）上溢过程，一般是建立大根堆的过程
5）heapify过程 = 下溢过程，一般是取出根节点后的完全二叉树调整的过程
6）heapSize是标记堆是否越界的标记，arr.length是标记数组是否越界的标记


4- 求某个数列中的中位数问题：【堆的应用，加快寻找的过程】
1）中位数，是一组有序数列中的中间位置的数，若数列为奇数则为中间的数，若数列为偶数则为中间两个数相加除以2
2）大根堆和小根堆的方式求解中位数问题，大根堆存储的是数列中较小的n/2的数，小根堆存储的是数列中较大的n/2的数，两者的数量的差距不能超过1
所以大根堆存储较小的n/2的子数列，根节点是子数列最大的数； 小根堆是较大的n/2的子数列，其根节点是子数列中的最小值
=>所以中位数是 ①若两heap的大小一样，则整体数列是偶数，取两者之和除以2   ②若两heap的大小不一样大，则取较大的一边的根节点为中位数


5- 排序算法的稳定性：
如 3 1 2 3 2 1 5 5 ， 排序后是 1 1 2 2 3 3 5 5 ， 第一个3和第二个3的位置是否发生变化，若是不变的，则次算法是稳定的



